import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
};

export type Code = {
  __typename?: 'Code';
  id: Scalars['ID']['output'];
  line: Line;
  lineId: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type CodeAttributes = {
  lineId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of CreateCode */
export type CreateCodeInput = {
  attributes: CodeAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateCode. */
export type CreateCodePayload = {
  __typename?: 'CreateCodePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  codes?: Maybe<Array<Code>>;
  error?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of CreateFactory */
export type CreateFactoryInput = {
  attributes: FactoryAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateFactory. */
export type CreateFactoryPayload = {
  __typename?: 'CreateFactoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  factory?: Maybe<Factory>;
};

/** Autogenerated input type of CreateLineError */
export type CreateLineErrorInput = {
  attributes: LineErrorAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateLineError. */
export type CreateLineErrorPayload = {
  __typename?: 'CreateLineErrorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lineErrors?: Maybe<Array<LineError>>;
};

/** Autogenerated input type of CreateLine */
export type CreateLineInput = {
  attributes: LineAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateLine. */
export type CreateLinePayload = {
  __typename?: 'CreateLinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lines?: Maybe<Array<Line>>;
};

/** Autogenerated input type of CreateLineUser */
export type CreateLineUserInput = {
  attributes: LineUserAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateLineUser. */
export type CreateLineUserPayload = {
  __typename?: 'CreateLineUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lineUser?: Maybe<LineUser>;
};

/** Autogenerated input type of CreateProduct */
export type CreateProductInput = {
  attributes: ProductAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateProduct. */
export type CreateProductPayload = {
  __typename?: 'CreateProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  products?: Maybe<Array<Product>>;
};

/** Autogenerated input type of CreateSearchCondition */
export type CreateSearchConditionInput = {
  attributes: SearchConditionAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of CreateSearchCondition. */
export type CreateSearchConditionPayload = {
  __typename?: 'CreateSearchConditionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  searchConditions?: Maybe<Array<SearchCondition>>;
};

export type Factory = {
  __typename?: 'Factory';
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type FactoryAttributes = {
  name?: InputMaybe<Scalars['String']['input']>;
};

export type Line = {
  __typename?: 'Line';
  codeCount?: Maybe<Scalars['Int']['output']>;
  factory: Factory;
  factoryId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  product: Product;
  productId: Scalars['ID']['output'];
  takt?: Maybe<Scalars['Float']['output']>;
  userCount?: Maybe<Scalars['Int']['output']>;
};

export type LineAttributes = {
  factoryId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  productId?: InputMaybe<Scalars['ID']['input']>;
  takt?: InputMaybe<Scalars['Float']['input']>;
};

export type LineError = {
  __typename?: 'LineError';
  id: Scalars['ID']['output'];
  line: Line;
  lineId: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type LineErrorAttributes = {
  lineId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type LineUser = {
  __typename?: 'LineUser';
  id: Scalars['ID']['output'];
  line: Line;
  lineId: Scalars['ID']['output'];
  user: User;
  userId: Scalars['ID']['output'];
};

export type LineUserAttributes = {
  lineId?: InputMaybe<Scalars['ID']['input']>;
  userId?: InputMaybe<Scalars['ID']['input']>;
};

export type MasterSearch = {
  factoryId?: InputMaybe<Scalars['ID']['input']>;
  keyword?: InputMaybe<Scalars['String']['input']>;
  lineIds?: InputMaybe<Array<Scalars['ID']['input']>>;
  productId?: InputMaybe<Scalars['ID']['input']>;
};

export type Mutation = {
  __typename?: 'Mutation';
  createCode: CreateCodePayload;
  createFactory: CreateFactoryPayload;
  createLine: CreateLinePayload;
  createLineError: CreateLineErrorPayload;
  createLineUser: CreateLineUserPayload;
  createProduct: CreateProductPayload;
  createSearchCondition: CreateSearchConditionPayload;
  removeCode: RemoveCodePayload;
  removeFactory: RemoveFactoryPayload;
  removeLine: RemoveLinePayload;
  removeLineError: RemoveLineErrorPayload;
  removeLineUser: RemoveLineUserPayload;
  removeProduct: RemoveProductPayload;
  removeSearchCondition: RemoveSearchConditionPayload;
  /** An example field added by the generator */
  testField: Scalars['String']['output'];
  updateCode: UpdateCodePayload;
  updateFactory: UpdateFactoryPayload;
  updateLine: UpdateLinePayload;
  updateLineError: UpdateLineErrorPayload;
  updateLineUser: UpdateLineUserPayload;
  updateProduct: UpdateProductPayload;
  updateSearchCondition: UpdateSearchConditionPayload;
};


export type MutationCreateCodeArgs = {
  input: CreateCodeInput;
};


export type MutationCreateFactoryArgs = {
  input: CreateFactoryInput;
};


export type MutationCreateLineArgs = {
  input: CreateLineInput;
};


export type MutationCreateLineErrorArgs = {
  input: CreateLineErrorInput;
};


export type MutationCreateLineUserArgs = {
  input: CreateLineUserInput;
};


export type MutationCreateProductArgs = {
  input: CreateProductInput;
};


export type MutationCreateSearchConditionArgs = {
  input: CreateSearchConditionInput;
};


export type MutationRemoveCodeArgs = {
  input: RemoveCodeInput;
};


export type MutationRemoveFactoryArgs = {
  input: RemoveFactoryInput;
};


export type MutationRemoveLineArgs = {
  input: RemoveLineInput;
};


export type MutationRemoveLineErrorArgs = {
  input: RemoveLineErrorInput;
};


export type MutationRemoveLineUserArgs = {
  input: RemoveLineUserInput;
};


export type MutationRemoveProductArgs = {
  input: RemoveProductInput;
};


export type MutationRemoveSearchConditionArgs = {
  input: RemoveSearchConditionInput;
};


export type MutationUpdateCodeArgs = {
  input: UpdateCodeInput;
};


export type MutationUpdateFactoryArgs = {
  input: UpdateFactoryInput;
};


export type MutationUpdateLineArgs = {
  input: UpdateLineInput;
};


export type MutationUpdateLineErrorArgs = {
  input: UpdateLineErrorInput;
};


export type MutationUpdateLineUserArgs = {
  input: UpdateLineUserInput;
};


export type MutationUpdateProductArgs = {
  input: UpdateProductInput;
};


export type MutationUpdateSearchConditionArgs = {
  input: UpdateSearchConditionInput;
};

export type Product = {
  __typename?: 'Product';
  factory?: Maybe<Factory>;
  factoryId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
};

export type ProductAttributes = {
  factoryId?: InputMaybe<Scalars['ID']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

export type Query = {
  __typename?: 'Query';
  codes?: Maybe<Array<Code>>;
  factories?: Maybe<Array<Factory>>;
  line?: Maybe<Line>;
  lineErrors?: Maybe<Array<LineError>>;
  lineUsers?: Maybe<Array<LineUser>>;
  lines?: Maybe<Array<Line>>;
  products?: Maybe<Array<Product>>;
  reportAvailabilityRate?: Maybe<Array<ReportAvailabilityRate>>;
  reportDailyLineCodes?: Maybe<Array<ReportDailyLineCode>>;
  reportErrors?: Maybe<Array<ReportError>>;
  reportLineRate?: Maybe<Array<ReportLineRate>>;
  searchConditions?: Maybe<Array<SearchCondition>>;
  /** An example field added by the generator */
  testField: Scalars['String']['output'];
  user?: Maybe<User>;
  users?: Maybe<Array<User>>;
};


export type QueryCodesArgs = {
  search?: InputMaybe<MasterSearch>;
};


export type QueryFactoriesArgs = {
  search?: InputMaybe<MasterSearch>;
};


export type QueryLineArgs = {
  id?: InputMaybe<Scalars['ID']['input']>;
};


export type QueryLineErrorsArgs = {
  search?: InputMaybe<MasterSearch>;
};


export type QueryLineUsersArgs = {
  search?: InputMaybe<MasterSearch>;
};


export type QueryLinesArgs = {
  search?: InputMaybe<MasterSearch>;
};


export type QueryProductsArgs = {
  search?: InputMaybe<MasterSearch>;
};


export type QueryReportAvailabilityRateArgs = {
  search?: InputMaybe<ReportSearch>;
};


export type QueryReportDailyLineCodesArgs = {
  search?: InputMaybe<ReportSearch>;
};


export type QueryReportErrorsArgs = {
  search?: InputMaybe<ReportSearch>;
};


export type QueryReportLineRateArgs = {
  search?: InputMaybe<ReportSearch>;
};


export type QuerySearchConditionsArgs = {
  search?: InputMaybe<SearchConditionSearch>;
};


export type QueryUserArgs = {
  id: Scalars['ID']['input'];
};

/** Autogenerated input type of RemoveCode */
export type RemoveCodeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveCode. */
export type RemoveCodePayload = {
  __typename?: 'RemoveCodePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Code>;
  error?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of RemoveFactory */
export type RemoveFactoryInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveFactory. */
export type RemoveFactoryPayload = {
  __typename?: 'RemoveFactoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  factory?: Maybe<Factory>;
};

/** Autogenerated input type of RemoveLineError */
export type RemoveLineErrorInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveLineError. */
export type RemoveLineErrorPayload = {
  __typename?: 'RemoveLineErrorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lineError?: Maybe<LineError>;
};

/** Autogenerated input type of RemoveLine */
export type RemoveLineInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveLine. */
export type RemoveLinePayload = {
  __typename?: 'RemoveLinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  line?: Maybe<Line>;
};

/** Autogenerated input type of RemoveLineUser */
export type RemoveLineUserInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveLineUser. */
export type RemoveLineUserPayload = {
  __typename?: 'RemoveLineUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lineUser?: Maybe<LineUser>;
};

/** Autogenerated input type of RemoveProduct */
export type RemoveProductInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveProduct. */
export type RemoveProductPayload = {
  __typename?: 'RemoveProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  product?: Maybe<Product>;
};

/** Autogenerated input type of RemoveSearchCondition */
export type RemoveSearchConditionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of RemoveSearchCondition. */
export type RemoveSearchConditionPayload = {
  __typename?: 'RemoveSearchConditionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  searchCondition?: Maybe<SearchCondition>;
};

export type ReportAvailabilityRate = {
  __typename?: 'ReportAvailabilityRate';
  date?: Maybe<Scalars['String']['output']>;
  line?: Maybe<Line>;
  lineId: Scalars['ID']['output'];
  lineName: Scalars['String']['output'];
  prevDate?: Maybe<Scalars['String']['output']>;
  prevRate?: Maybe<Scalars['Float']['output']>;
  rate?: Maybe<Scalars['Float']['output']>;
};

export type ReportDailyLineCode = {
  __typename?: 'ReportDailyLineCode';
  count: Scalars['Int']['output'];
  date: Scalars['String']['output'];
};

export type ReportError = {
  __typename?: 'ReportError';
  count: Scalars['Int']['output'];
  line?: Maybe<Line>;
  lineName?: Maybe<Scalars['String']['output']>;
};

export type ReportLineRate = {
  __typename?: 'ReportLineRate';
  lineId: Scalars['ID']['output'];
  lineName: Scalars['String']['output'];
  month?: Maybe<Scalars['String']['output']>;
  rate?: Maybe<Scalars['Int']['output']>;
};

export type ReportSearch = {
  codeIds?: InputMaybe<Array<Scalars['String']['input']>>;
  dateFrom?: InputMaybe<Scalars['String']['input']>;
  dateTo?: InputMaybe<Scalars['String']['input']>;
  exceptZero?: InputMaybe<Scalars['Boolean']['input']>;
  lineIds?: InputMaybe<Array<Scalars['String']['input']>>;
  month?: InputMaybe<Scalars['String']['input']>;
  monthFrom?: InputMaybe<Scalars['String']['input']>;
  monthTo?: InputMaybe<Scalars['String']['input']>;
};

export type SearchCondition = {
  __typename?: 'SearchCondition';
  codeIds?: Maybe<Array<Scalars['String']['output']>>;
  dateFrom?: Maybe<Scalars['String']['output']>;
  dateTo?: Maybe<Scalars['String']['output']>;
  exceptZero?: Maybe<Scalars['Boolean']['output']>;
  fontSize?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  isAvarage?: Maybe<Scalars['Boolean']['output']>;
  isStandard?: Maybe<Scalars['Boolean']['output']>;
  lineIds?: Maybe<Array<Scalars['String']['output']>>;
  month?: Maybe<Scalars['String']['output']>;
  monthFrom?: Maybe<Scalars['String']['output']>;
  monthTo?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  position: Scalars['Int']['output'];
  reportType: Scalars['String']['output'];
  reportTypeI18n: Scalars['String']['output'];
  standard?: Maybe<Scalars['Int']['output']>;
};

export type SearchConditionAttributes = {
  codeIds?: InputMaybe<Array<Scalars['String']['input']>>;
  dateFrom?: InputMaybe<Scalars['String']['input']>;
  dateTo?: InputMaybe<Scalars['String']['input']>;
  exceptZero?: InputMaybe<Scalars['Boolean']['input']>;
  fontSize?: InputMaybe<Scalars['String']['input']>;
  isAvarage?: InputMaybe<Scalars['Boolean']['input']>;
  isStandard?: InputMaybe<Scalars['Boolean']['input']>;
  lineIds?: InputMaybe<Array<Scalars['String']['input']>>;
  month?: InputMaybe<Scalars['String']['input']>;
  monthFrom?: InputMaybe<Scalars['String']['input']>;
  monthTo?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  reportType?: InputMaybe<Scalars['String']['input']>;
  standard?: InputMaybe<Scalars['Int']['input']>;
};

export type SearchConditionSearch = {
  keyword?: InputMaybe<Scalars['String']['input']>;
  reportType?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated input type of UpdateCode */
export type UpdateCodeInput = {
  attributes: CodeAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateCode. */
export type UpdateCodePayload = {
  __typename?: 'UpdateCodePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Code>;
  error?: Maybe<Scalars['String']['output']>;
};

/** Autogenerated input type of UpdateFactory */
export type UpdateFactoryInput = {
  attributes: FactoryAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateFactory. */
export type UpdateFactoryPayload = {
  __typename?: 'UpdateFactoryPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  factory?: Maybe<Factory>;
};

/** Autogenerated input type of UpdateLineError */
export type UpdateLineErrorInput = {
  attributes: LineErrorAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateLineError. */
export type UpdateLineErrorPayload = {
  __typename?: 'UpdateLineErrorPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lineError?: Maybe<LineError>;
};

/** Autogenerated input type of UpdateLine */
export type UpdateLineInput = {
  attributes: LineAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateLine. */
export type UpdateLinePayload = {
  __typename?: 'UpdateLinePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  line?: Maybe<Line>;
};

/** Autogenerated input type of UpdateLineUser */
export type UpdateLineUserInput = {
  attributes: LineUserAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateLineUser. */
export type UpdateLineUserPayload = {
  __typename?: 'UpdateLineUserPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  lineUser?: Maybe<LineUser>;
};

/** Autogenerated input type of UpdateProduct */
export type UpdateProductInput = {
  attributes: ProductAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateProduct. */
export type UpdateProductPayload = {
  __typename?: 'UpdateProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  product?: Maybe<Product>;
};

/** Autogenerated input type of UpdateSearchCondition */
export type UpdateSearchConditionInput = {
  attributes: SearchConditionAttributes;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdateSearchCondition. */
export type UpdateSearchConditionPayload = {
  __typename?: 'UpdateSearchConditionPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  error?: Maybe<Scalars['String']['output']>;
  searchCondition?: Maybe<SearchCondition>;
};

export type User = {
  __typename?: 'User';
  email: Scalars['String']['output'];
  firstName?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastName?: Maybe<Scalars['String']['output']>;
  password: Scalars['String']['output'];
  role: Scalars['String']['output'];
  roleI18n?: Maybe<Scalars['String']['output']>;
};

export type CodeFragmentFragment = { __typename?: 'Code', id: string, lineId: string, name: string };

export type FactoryFragmentFragment = { __typename?: 'Factory', id: string, name: string };

export type LineFragmentFragment = { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, takt?: number | null };

export type LineErrorFragmentFragment = { __typename?: 'LineError', id: string, lineId: string, name: string };

export type LineUserFragmentFragment = { __typename?: 'LineUser', id: string, lineId: string, userId: string };

export type ProductFragmentFragment = { __typename?: 'Product', id: string, factoryId: string, name: string };

export type ReportDailyLineCodeFragmentFragment = { __typename?: 'ReportDailyLineCode', date: string, count: number };

export type SearchConditionFragmentFragment = { __typename?: 'SearchCondition', id: string, name: string, reportType: string, reportTypeI18n: string, dateFrom?: string | null, dateTo?: string | null, monthFrom?: string | null, monthTo?: string | null, month?: string | null, lineIds?: Array<string> | null, codeIds?: Array<string> | null, isStandard?: boolean | null, standard?: number | null, isAvarage?: boolean | null, exceptZero?: boolean | null, position: number, fontSize?: string | null };

export type UserFragmentFragment = { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string };

export type CreateCodeMutationVariables = Exact<{
  attributes: CodeAttributes;
}>;


export type CreateCodeMutation = { __typename?: 'Mutation', createCode: { __typename?: 'CreateCodePayload', error?: string | null, codes?: Array<{ __typename?: 'Code', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string } }> | null } };

export type RemoveCodeMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveCodeMutation = { __typename?: 'Mutation', removeCode: { __typename?: 'RemoveCodePayload', error?: string | null, code?: { __typename?: 'Code', id: string, lineId: string, name: string } | null } };

export type UpdateCodeMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: CodeAttributes;
}>;


export type UpdateCodeMutation = { __typename?: 'Mutation', updateCode: { __typename?: 'UpdateCodePayload', error?: string | null, code?: { __typename?: 'Code', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string } } | null } };

export type CreateFactoryMutationVariables = Exact<{
  attributes: FactoryAttributes;
}>;


export type CreateFactoryMutation = { __typename?: 'Mutation', createFactory: { __typename?: 'CreateFactoryPayload', error?: string | null, factory?: { __typename?: 'Factory', id: string, name: string } | null } };

export type RemoveFactoryMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveFactoryMutation = { __typename?: 'Mutation', removeFactory: { __typename?: 'RemoveFactoryPayload', error?: string | null, factory?: { __typename?: 'Factory', id: string, name: string } | null } };

export type UpdateFactoryMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: FactoryAttributes;
}>;


export type UpdateFactoryMutation = { __typename?: 'Mutation', updateFactory: { __typename?: 'UpdateFactoryPayload', error?: string | null, factory?: { __typename?: 'Factory', id: string, name: string } | null } };

export type CreateLineMutationVariables = Exact<{
  attributes: LineAttributes;
}>;


export type CreateLineMutation = { __typename?: 'Mutation', createLine: { __typename?: 'CreateLinePayload', error?: string | null, lines?: Array<{ __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, takt?: number | null }> | null } };

export type RemoveLineMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveLineMutation = { __typename?: 'Mutation', removeLine: { __typename?: 'RemoveLinePayload', error?: string | null, line?: { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, takt?: number | null } | null } };

export type UpdateLineMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: LineAttributes;
}>;


export type UpdateLineMutation = { __typename?: 'Mutation', updateLine: { __typename?: 'UpdateLinePayload', error?: string | null, line?: { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, takt?: number | null } | null } };

export type CreateLineErrorMutationVariables = Exact<{
  attributes: LineErrorAttributes;
}>;


export type CreateLineErrorMutation = { __typename?: 'Mutation', createLineError: { __typename?: 'CreateLineErrorPayload', error?: string | null, lineErrors?: Array<{ __typename?: 'LineError', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string } }> | null } };

export type RemoveLineErrorMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveLineErrorMutation = { __typename?: 'Mutation', removeLineError: { __typename?: 'RemoveLineErrorPayload', error?: string | null, lineError?: { __typename?: 'LineError', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string } } | null } };

export type UpdateLineErrorMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: LineErrorAttributes;
}>;


export type UpdateLineErrorMutation = { __typename?: 'Mutation', updateLineError: { __typename?: 'UpdateLineErrorPayload', error?: string | null, lineError?: { __typename?: 'LineError', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string } } | null } };

export type CreateLineUserMutationVariables = Exact<{
  attributes: LineUserAttributes;
}>;


export type CreateLineUserMutation = { __typename?: 'Mutation', createLineUser: { __typename?: 'CreateLineUserPayload', error?: string | null, lineUser?: { __typename?: 'LineUser', id: string, lineId: string, userId: string, line: { __typename?: 'Line', id: string, name: string }, user: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string } } | null } };

export type RemoveLineUserMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveLineUserMutation = { __typename?: 'Mutation', removeLineUser: { __typename?: 'RemoveLineUserPayload', error?: string | null, lineUser?: { __typename?: 'LineUser', id: string, lineId: string, userId: string, line: { __typename?: 'Line', id: string, name: string }, user: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string } } | null } };

export type UpdateLineUserMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: LineUserAttributes;
}>;


export type UpdateLineUserMutation = { __typename?: 'Mutation', updateLineUser: { __typename?: 'UpdateLineUserPayload', error?: string | null, lineUser?: { __typename?: 'LineUser', id: string, lineId: string, userId: string, line: { __typename?: 'Line', id: string, name: string }, user: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string } } | null } };

export type CreateProductMutationVariables = Exact<{
  attributes: ProductAttributes;
}>;


export type CreateProductMutation = { __typename?: 'Mutation', createProduct: { __typename?: 'CreateProductPayload', error?: string | null, products?: Array<{ __typename?: 'Product', id: string, factoryId: string, name: string, factory?: { __typename?: 'Factory', id: string, name: string } | null }> | null } };

export type RemoveProductMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveProductMutation = { __typename?: 'Mutation', removeProduct: { __typename?: 'RemoveProductPayload', error?: string | null, product?: { __typename?: 'Product', id: string, factoryId: string, name: string } | null } };

export type UpdateProductMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: ProductAttributes;
}>;


export type UpdateProductMutation = { __typename?: 'Mutation', updateProduct: { __typename?: 'UpdateProductPayload', error?: string | null, product?: { __typename?: 'Product', id: string, factoryId: string, name: string, factory?: { __typename?: 'Factory', id: string, name: string } | null } | null } };

export type CreateSearchConditionMutationVariables = Exact<{
  attributes: SearchConditionAttributes;
}>;


export type CreateSearchConditionMutation = { __typename?: 'Mutation', createSearchCondition: { __typename?: 'CreateSearchConditionPayload', error?: string | null, searchConditions?: Array<{ __typename?: 'SearchCondition', id: string, name: string, reportType: string, reportTypeI18n: string, dateFrom?: string | null, dateTo?: string | null, monthFrom?: string | null, monthTo?: string | null, month?: string | null, lineIds?: Array<string> | null, codeIds?: Array<string> | null, isStandard?: boolean | null, standard?: number | null, isAvarage?: boolean | null, exceptZero?: boolean | null, position: number, fontSize?: string | null }> | null } };

export type RemoveSearchConditionMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type RemoveSearchConditionMutation = { __typename?: 'Mutation', removeSearchCondition: { __typename?: 'RemoveSearchConditionPayload', error?: string | null, searchCondition?: { __typename?: 'SearchCondition', id: string, name: string, reportType: string, reportTypeI18n: string, dateFrom?: string | null, dateTo?: string | null, monthFrom?: string | null, monthTo?: string | null, month?: string | null, lineIds?: Array<string> | null, codeIds?: Array<string> | null, isStandard?: boolean | null, standard?: number | null, isAvarage?: boolean | null, exceptZero?: boolean | null, position: number, fontSize?: string | null } | null } };

export type UpdateSearchConditionMutationVariables = Exact<{
  id: Scalars['ID']['input'];
  attributes: SearchConditionAttributes;
}>;


export type UpdateSearchConditionMutation = { __typename?: 'Mutation', updateSearchCondition: { __typename?: 'UpdateSearchConditionPayload', error?: string | null, searchCondition?: { __typename?: 'SearchCondition', id: string, name: string, reportType: string, reportTypeI18n: string, dateFrom?: string | null, dateTo?: string | null, monthFrom?: string | null, monthTo?: string | null, month?: string | null, lineIds?: Array<string> | null, codeIds?: Array<string> | null, isStandard?: boolean | null, standard?: number | null, isAvarage?: boolean | null, exceptZero?: boolean | null, position: number, fontSize?: string | null } | null } };

export type CodesQueryVariables = Exact<{
  search?: InputMaybe<MasterSearch>;
}>;


export type CodesQuery = { __typename?: 'Query', codes?: Array<{ __typename?: 'Code', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, factory: { __typename?: 'Factory', id: string, name: string }, product: { __typename?: 'Product', id: string, factoryId: string, name: string } } }> | null };

export type FactoriesQueryVariables = Exact<{
  search?: InputMaybe<MasterSearch>;
}>;


export type FactoriesQuery = { __typename?: 'Query', factories?: Array<{ __typename?: 'Factory', id: string, name: string }> | null };

export type LineQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type LineQuery = { __typename?: 'Query', line?: { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, takt?: number | null, codeCount?: number | null, userCount?: number | null, factory: { __typename?: 'Factory', id: string, name: string }, product: { __typename?: 'Product', id: string, factoryId: string, name: string } } | null };

export type LinesQueryVariables = Exact<{
  search?: InputMaybe<MasterSearch>;
}>;


export type LinesQuery = { __typename?: 'Query', lines?: Array<{ __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, takt?: number | null, codeCount?: number | null, userCount?: number | null, factory: { __typename?: 'Factory', id: string, name: string }, product: { __typename?: 'Product', id: string, factoryId: string, name: string } }> | null };

export type LineErrorsQueryVariables = Exact<{
  search?: InputMaybe<MasterSearch>;
}>;


export type LineErrorsQuery = { __typename?: 'Query', lineErrors?: Array<{ __typename?: 'LineError', id: string, lineId: string, name: string, line: { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, factory: { __typename?: 'Factory', id: string, name: string }, product: { __typename?: 'Product', id: string, factoryId: string, name: string } } }> | null };

export type LineUsersQueryVariables = Exact<{
  search?: InputMaybe<MasterSearch>;
}>;


export type LineUsersQuery = { __typename?: 'Query', lineUsers?: Array<{ __typename?: 'LineUser', id: string, lineId: string, userId: string, line: { __typename?: 'Line', id: string, name: string, factoryId: string, productId: string, factory: { __typename?: 'Factory', id: string, name: string }, product: { __typename?: 'Product', id: string, factoryId: string, name: string } }, user: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string } }> | null };

export type ProductsQueryVariables = Exact<{
  search?: InputMaybe<MasterSearch>;
}>;


export type ProductsQuery = { __typename?: 'Query', products?: Array<{ __typename?: 'Product', id: string, factoryId: string, name: string, factory?: { __typename?: 'Factory', id: string, name: string } | null }> | null };

export type ReportAvailabilityRateQueryVariables = Exact<{
  search?: InputMaybe<ReportSearch>;
}>;


export type ReportAvailabilityRateQuery = { __typename?: 'Query', reportAvailabilityRate?: Array<{ __typename?: 'ReportAvailabilityRate', lineId: string, lineName: string, date?: string | null, rate?: number | null, prevRate?: number | null }> | null };

export type ReportDailyLineCodesQueryVariables = Exact<{
  search?: InputMaybe<ReportSearch>;
}>;


export type ReportDailyLineCodesQuery = { __typename?: 'Query', reportDailyLineCodes?: Array<{ __typename?: 'ReportDailyLineCode', date: string, count: number }> | null };

export type ReportErrorsQueryVariables = Exact<{
  search?: InputMaybe<ReportSearch>;
}>;


export type ReportErrorsQuery = { __typename?: 'Query', reportErrors?: Array<{ __typename?: 'ReportError', lineName?: string | null, count: number }> | null };

export type ReportLineRateQueryVariables = Exact<{
  search?: InputMaybe<ReportSearch>;
}>;


export type ReportLineRateQuery = { __typename?: 'Query', reportLineRate?: Array<{ __typename?: 'ReportLineRate', month?: string | null, lineId: string, lineName: string, rate?: number | null }> | null };

export type SearchConditionsQueryVariables = Exact<{
  search?: InputMaybe<SearchConditionSearch>;
}>;


export type SearchConditionsQuery = { __typename?: 'Query', searchConditions?: Array<{ __typename?: 'SearchCondition', id: string, name: string, reportType: string, reportTypeI18n: string, dateFrom?: string | null, dateTo?: string | null, monthFrom?: string | null, monthTo?: string | null, month?: string | null, lineIds?: Array<string> | null, codeIds?: Array<string> | null, isStandard?: boolean | null, standard?: number | null, isAvarage?: boolean | null, exceptZero?: boolean | null, position: number, fontSize?: string | null }> | null };

export type UserQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type UserQuery = { __typename?: 'Query', user?: { __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string } | null };

export type UsersQueryVariables = Exact<{ [key: string]: never; }>;


export type UsersQuery = { __typename?: 'Query', users?: Array<{ __typename?: 'User', id: string, email: string, role: string, firstName?: string | null, lastName?: string | null, fullName?: string | null, password: string }> | null };

export const CodeFragmentFragmentDoc = gql`
    fragment codeFragment on Code {
  id
  lineId
  name
}
    `;
export const FactoryFragmentFragmentDoc = gql`
    fragment factoryFragment on Factory {
  id
  name
}
    `;
export const LineFragmentFragmentDoc = gql`
    fragment lineFragment on Line {
  id
  name
  factoryId
  productId
  takt
}
    `;
export const LineErrorFragmentFragmentDoc = gql`
    fragment lineErrorFragment on LineError {
  id
  lineId
  name
}
    `;
export const LineUserFragmentFragmentDoc = gql`
    fragment lineUserFragment on LineUser {
  id
  lineId
  userId
}
    `;
export const ProductFragmentFragmentDoc = gql`
    fragment productFragment on Product {
  id
  factoryId
  name
}
    `;
export const ReportDailyLineCodeFragmentFragmentDoc = gql`
    fragment reportDailyLineCodeFragment on ReportDailyLineCode {
  date
  count
}
    `;
export const SearchConditionFragmentFragmentDoc = gql`
    fragment searchConditionFragment on SearchCondition {
  id
  name
  reportType
  reportTypeI18n
  dateFrom
  dateTo
  monthFrom
  monthTo
  month
  lineIds
  codeIds
  isStandard
  standard
  isAvarage
  exceptZero
  position
  fontSize
}
    `;
export const UserFragmentFragmentDoc = gql`
    fragment userFragment on User {
  id
  email
  role
  firstName
  lastName
  fullName
  password
}
    `;
export const CreateCodeDocument = gql`
    mutation createCode($attributes: CodeAttributes!) {
  createCode(input: {attributes: $attributes}) {
    codes {
      ...codeFragment
      line {
        id
        name
      }
    }
    error
  }
}
    ${CodeFragmentFragmentDoc}`;
export type CreateCodeMutationFn = Apollo.MutationFunction<CreateCodeMutation, CreateCodeMutationVariables>;

/**
 * __useCreateCodeMutation__
 *
 * To run a mutation, you first call `useCreateCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCodeMutation, { data, loading, error }] = useCreateCodeMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateCodeMutation(baseOptions?: Apollo.MutationHookOptions<CreateCodeMutation, CreateCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCodeMutation, CreateCodeMutationVariables>(CreateCodeDocument, options);
      }
export type CreateCodeMutationHookResult = ReturnType<typeof useCreateCodeMutation>;
export type CreateCodeMutationResult = Apollo.MutationResult<CreateCodeMutation>;
export type CreateCodeMutationOptions = Apollo.BaseMutationOptions<CreateCodeMutation, CreateCodeMutationVariables>;
export const RemoveCodeDocument = gql`
    mutation removeCode($id: ID!) {
  removeCode(input: {id: $id}) {
    code {
      ...codeFragment
    }
    error
  }
}
    ${CodeFragmentFragmentDoc}`;
export type RemoveCodeMutationFn = Apollo.MutationFunction<RemoveCodeMutation, RemoveCodeMutationVariables>;

/**
 * __useRemoveCodeMutation__
 *
 * To run a mutation, you first call `useRemoveCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCodeMutation, { data, loading, error }] = useRemoveCodeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveCodeMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCodeMutation, RemoveCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveCodeMutation, RemoveCodeMutationVariables>(RemoveCodeDocument, options);
      }
export type RemoveCodeMutationHookResult = ReturnType<typeof useRemoveCodeMutation>;
export type RemoveCodeMutationResult = Apollo.MutationResult<RemoveCodeMutation>;
export type RemoveCodeMutationOptions = Apollo.BaseMutationOptions<RemoveCodeMutation, RemoveCodeMutationVariables>;
export const UpdateCodeDocument = gql`
    mutation updateCode($id: ID!, $attributes: CodeAttributes!) {
  updateCode(input: {id: $id, attributes: $attributes}) {
    code {
      ...codeFragment
      line {
        id
        name
      }
    }
    error
  }
}
    ${CodeFragmentFragmentDoc}`;
export type UpdateCodeMutationFn = Apollo.MutationFunction<UpdateCodeMutation, UpdateCodeMutationVariables>;

/**
 * __useUpdateCodeMutation__
 *
 * To run a mutation, you first call `useUpdateCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCodeMutation, { data, loading, error }] = useUpdateCodeMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateCodeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCodeMutation, UpdateCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCodeMutation, UpdateCodeMutationVariables>(UpdateCodeDocument, options);
      }
export type UpdateCodeMutationHookResult = ReturnType<typeof useUpdateCodeMutation>;
export type UpdateCodeMutationResult = Apollo.MutationResult<UpdateCodeMutation>;
export type UpdateCodeMutationOptions = Apollo.BaseMutationOptions<UpdateCodeMutation, UpdateCodeMutationVariables>;
export const CreateFactoryDocument = gql`
    mutation createFactory($attributes: FactoryAttributes!) {
  createFactory(input: {attributes: $attributes}) {
    factory {
      ...factoryFragment
    }
    error
  }
}
    ${FactoryFragmentFragmentDoc}`;
export type CreateFactoryMutationFn = Apollo.MutationFunction<CreateFactoryMutation, CreateFactoryMutationVariables>;

/**
 * __useCreateFactoryMutation__
 *
 * To run a mutation, you first call `useCreateFactoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateFactoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createFactoryMutation, { data, loading, error }] = useCreateFactoryMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateFactoryMutation(baseOptions?: Apollo.MutationHookOptions<CreateFactoryMutation, CreateFactoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateFactoryMutation, CreateFactoryMutationVariables>(CreateFactoryDocument, options);
      }
export type CreateFactoryMutationHookResult = ReturnType<typeof useCreateFactoryMutation>;
export type CreateFactoryMutationResult = Apollo.MutationResult<CreateFactoryMutation>;
export type CreateFactoryMutationOptions = Apollo.BaseMutationOptions<CreateFactoryMutation, CreateFactoryMutationVariables>;
export const RemoveFactoryDocument = gql`
    mutation removeFactory($id: ID!) {
  removeFactory(input: {id: $id}) {
    factory {
      ...factoryFragment
    }
    error
  }
}
    ${FactoryFragmentFragmentDoc}`;
export type RemoveFactoryMutationFn = Apollo.MutationFunction<RemoveFactoryMutation, RemoveFactoryMutationVariables>;

/**
 * __useRemoveFactoryMutation__
 *
 * To run a mutation, you first call `useRemoveFactoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveFactoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeFactoryMutation, { data, loading, error }] = useRemoveFactoryMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveFactoryMutation(baseOptions?: Apollo.MutationHookOptions<RemoveFactoryMutation, RemoveFactoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveFactoryMutation, RemoveFactoryMutationVariables>(RemoveFactoryDocument, options);
      }
export type RemoveFactoryMutationHookResult = ReturnType<typeof useRemoveFactoryMutation>;
export type RemoveFactoryMutationResult = Apollo.MutationResult<RemoveFactoryMutation>;
export type RemoveFactoryMutationOptions = Apollo.BaseMutationOptions<RemoveFactoryMutation, RemoveFactoryMutationVariables>;
export const UpdateFactoryDocument = gql`
    mutation updateFactory($id: ID!, $attributes: FactoryAttributes!) {
  updateFactory(input: {id: $id, attributes: $attributes}) {
    factory {
      ...factoryFragment
    }
    error
  }
}
    ${FactoryFragmentFragmentDoc}`;
export type UpdateFactoryMutationFn = Apollo.MutationFunction<UpdateFactoryMutation, UpdateFactoryMutationVariables>;

/**
 * __useUpdateFactoryMutation__
 *
 * To run a mutation, you first call `useUpdateFactoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateFactoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateFactoryMutation, { data, loading, error }] = useUpdateFactoryMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateFactoryMutation(baseOptions?: Apollo.MutationHookOptions<UpdateFactoryMutation, UpdateFactoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateFactoryMutation, UpdateFactoryMutationVariables>(UpdateFactoryDocument, options);
      }
export type UpdateFactoryMutationHookResult = ReturnType<typeof useUpdateFactoryMutation>;
export type UpdateFactoryMutationResult = Apollo.MutationResult<UpdateFactoryMutation>;
export type UpdateFactoryMutationOptions = Apollo.BaseMutationOptions<UpdateFactoryMutation, UpdateFactoryMutationVariables>;
export const CreateLineDocument = gql`
    mutation createLine($attributes: LineAttributes!) {
  createLine(input: {attributes: $attributes}) {
    lines {
      ...lineFragment
    }
    error
  }
}
    ${LineFragmentFragmentDoc}`;
export type CreateLineMutationFn = Apollo.MutationFunction<CreateLineMutation, CreateLineMutationVariables>;

/**
 * __useCreateLineMutation__
 *
 * To run a mutation, you first call `useCreateLineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLineMutation, { data, loading, error }] = useCreateLineMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateLineMutation(baseOptions?: Apollo.MutationHookOptions<CreateLineMutation, CreateLineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateLineMutation, CreateLineMutationVariables>(CreateLineDocument, options);
      }
export type CreateLineMutationHookResult = ReturnType<typeof useCreateLineMutation>;
export type CreateLineMutationResult = Apollo.MutationResult<CreateLineMutation>;
export type CreateLineMutationOptions = Apollo.BaseMutationOptions<CreateLineMutation, CreateLineMutationVariables>;
export const RemoveLineDocument = gql`
    mutation removeLine($id: ID!) {
  removeLine(input: {id: $id}) {
    line {
      ...lineFragment
    }
    error
  }
}
    ${LineFragmentFragmentDoc}`;
export type RemoveLineMutationFn = Apollo.MutationFunction<RemoveLineMutation, RemoveLineMutationVariables>;

/**
 * __useRemoveLineMutation__
 *
 * To run a mutation, you first call `useRemoveLineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveLineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeLineMutation, { data, loading, error }] = useRemoveLineMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveLineMutation(baseOptions?: Apollo.MutationHookOptions<RemoveLineMutation, RemoveLineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveLineMutation, RemoveLineMutationVariables>(RemoveLineDocument, options);
      }
export type RemoveLineMutationHookResult = ReturnType<typeof useRemoveLineMutation>;
export type RemoveLineMutationResult = Apollo.MutationResult<RemoveLineMutation>;
export type RemoveLineMutationOptions = Apollo.BaseMutationOptions<RemoveLineMutation, RemoveLineMutationVariables>;
export const UpdateLineDocument = gql`
    mutation updateLine($id: ID!, $attributes: LineAttributes!) {
  updateLine(input: {id: $id, attributes: $attributes}) {
    line {
      ...lineFragment
    }
    error
  }
}
    ${LineFragmentFragmentDoc}`;
export type UpdateLineMutationFn = Apollo.MutationFunction<UpdateLineMutation, UpdateLineMutationVariables>;

/**
 * __useUpdateLineMutation__
 *
 * To run a mutation, you first call `useUpdateLineMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLineMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLineMutation, { data, loading, error }] = useUpdateLineMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateLineMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLineMutation, UpdateLineMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLineMutation, UpdateLineMutationVariables>(UpdateLineDocument, options);
      }
export type UpdateLineMutationHookResult = ReturnType<typeof useUpdateLineMutation>;
export type UpdateLineMutationResult = Apollo.MutationResult<UpdateLineMutation>;
export type UpdateLineMutationOptions = Apollo.BaseMutationOptions<UpdateLineMutation, UpdateLineMutationVariables>;
export const CreateLineErrorDocument = gql`
    mutation createLineError($attributes: LineErrorAttributes!) {
  createLineError(input: {attributes: $attributes}) {
    lineErrors {
      ...lineErrorFragment
      line {
        id
        name
      }
    }
    error
  }
}
    ${LineErrorFragmentFragmentDoc}`;
export type CreateLineErrorMutationFn = Apollo.MutationFunction<CreateLineErrorMutation, CreateLineErrorMutationVariables>;

/**
 * __useCreateLineErrorMutation__
 *
 * To run a mutation, you first call `useCreateLineErrorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLineErrorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLineErrorMutation, { data, loading, error }] = useCreateLineErrorMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateLineErrorMutation(baseOptions?: Apollo.MutationHookOptions<CreateLineErrorMutation, CreateLineErrorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateLineErrorMutation, CreateLineErrorMutationVariables>(CreateLineErrorDocument, options);
      }
export type CreateLineErrorMutationHookResult = ReturnType<typeof useCreateLineErrorMutation>;
export type CreateLineErrorMutationResult = Apollo.MutationResult<CreateLineErrorMutation>;
export type CreateLineErrorMutationOptions = Apollo.BaseMutationOptions<CreateLineErrorMutation, CreateLineErrorMutationVariables>;
export const RemoveLineErrorDocument = gql`
    mutation removeLineError($id: ID!) {
  removeLineError(input: {id: $id}) {
    lineError {
      ...lineErrorFragment
      line {
        id
        name
      }
    }
    error
  }
}
    ${LineErrorFragmentFragmentDoc}`;
export type RemoveLineErrorMutationFn = Apollo.MutationFunction<RemoveLineErrorMutation, RemoveLineErrorMutationVariables>;

/**
 * __useRemoveLineErrorMutation__
 *
 * To run a mutation, you first call `useRemoveLineErrorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveLineErrorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeLineErrorMutation, { data, loading, error }] = useRemoveLineErrorMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveLineErrorMutation(baseOptions?: Apollo.MutationHookOptions<RemoveLineErrorMutation, RemoveLineErrorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveLineErrorMutation, RemoveLineErrorMutationVariables>(RemoveLineErrorDocument, options);
      }
export type RemoveLineErrorMutationHookResult = ReturnType<typeof useRemoveLineErrorMutation>;
export type RemoveLineErrorMutationResult = Apollo.MutationResult<RemoveLineErrorMutation>;
export type RemoveLineErrorMutationOptions = Apollo.BaseMutationOptions<RemoveLineErrorMutation, RemoveLineErrorMutationVariables>;
export const UpdateLineErrorDocument = gql`
    mutation updateLineError($id: ID!, $attributes: LineErrorAttributes!) {
  updateLineError(input: {id: $id, attributes: $attributes}) {
    lineError {
      ...lineErrorFragment
      line {
        id
        name
      }
    }
    error
  }
}
    ${LineErrorFragmentFragmentDoc}`;
export type UpdateLineErrorMutationFn = Apollo.MutationFunction<UpdateLineErrorMutation, UpdateLineErrorMutationVariables>;

/**
 * __useUpdateLineErrorMutation__
 *
 * To run a mutation, you first call `useUpdateLineErrorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLineErrorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLineErrorMutation, { data, loading, error }] = useUpdateLineErrorMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateLineErrorMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLineErrorMutation, UpdateLineErrorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLineErrorMutation, UpdateLineErrorMutationVariables>(UpdateLineErrorDocument, options);
      }
export type UpdateLineErrorMutationHookResult = ReturnType<typeof useUpdateLineErrorMutation>;
export type UpdateLineErrorMutationResult = Apollo.MutationResult<UpdateLineErrorMutation>;
export type UpdateLineErrorMutationOptions = Apollo.BaseMutationOptions<UpdateLineErrorMutation, UpdateLineErrorMutationVariables>;
export const CreateLineUserDocument = gql`
    mutation createLineUser($attributes: LineUserAttributes!) {
  createLineUser(input: {attributes: $attributes}) {
    lineUser {
      ...lineUserFragment
      line {
        id
        name
      }
      user {
        ...userFragment
      }
    }
    error
  }
}
    ${LineUserFragmentFragmentDoc}
${UserFragmentFragmentDoc}`;
export type CreateLineUserMutationFn = Apollo.MutationFunction<CreateLineUserMutation, CreateLineUserMutationVariables>;

/**
 * __useCreateLineUserMutation__
 *
 * To run a mutation, you first call `useCreateLineUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateLineUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createLineUserMutation, { data, loading, error }] = useCreateLineUserMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateLineUserMutation(baseOptions?: Apollo.MutationHookOptions<CreateLineUserMutation, CreateLineUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateLineUserMutation, CreateLineUserMutationVariables>(CreateLineUserDocument, options);
      }
export type CreateLineUserMutationHookResult = ReturnType<typeof useCreateLineUserMutation>;
export type CreateLineUserMutationResult = Apollo.MutationResult<CreateLineUserMutation>;
export type CreateLineUserMutationOptions = Apollo.BaseMutationOptions<CreateLineUserMutation, CreateLineUserMutationVariables>;
export const RemoveLineUserDocument = gql`
    mutation removeLineUser($id: ID!) {
  removeLineUser(input: {id: $id}) {
    lineUser {
      ...lineUserFragment
      line {
        id
        name
      }
      user {
        ...userFragment
      }
    }
    error
  }
}
    ${LineUserFragmentFragmentDoc}
${UserFragmentFragmentDoc}`;
export type RemoveLineUserMutationFn = Apollo.MutationFunction<RemoveLineUserMutation, RemoveLineUserMutationVariables>;

/**
 * __useRemoveLineUserMutation__
 *
 * To run a mutation, you first call `useRemoveLineUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveLineUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeLineUserMutation, { data, loading, error }] = useRemoveLineUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveLineUserMutation(baseOptions?: Apollo.MutationHookOptions<RemoveLineUserMutation, RemoveLineUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveLineUserMutation, RemoveLineUserMutationVariables>(RemoveLineUserDocument, options);
      }
export type RemoveLineUserMutationHookResult = ReturnType<typeof useRemoveLineUserMutation>;
export type RemoveLineUserMutationResult = Apollo.MutationResult<RemoveLineUserMutation>;
export type RemoveLineUserMutationOptions = Apollo.BaseMutationOptions<RemoveLineUserMutation, RemoveLineUserMutationVariables>;
export const UpdateLineUserDocument = gql`
    mutation updateLineUser($id: ID!, $attributes: LineUserAttributes!) {
  updateLineUser(input: {id: $id, attributes: $attributes}) {
    lineUser {
      ...lineUserFragment
      line {
        id
        name
      }
      user {
        ...userFragment
      }
    }
    error
  }
}
    ${LineUserFragmentFragmentDoc}
${UserFragmentFragmentDoc}`;
export type UpdateLineUserMutationFn = Apollo.MutationFunction<UpdateLineUserMutation, UpdateLineUserMutationVariables>;

/**
 * __useUpdateLineUserMutation__
 *
 * To run a mutation, you first call `useUpdateLineUserMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLineUserMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLineUserMutation, { data, loading, error }] = useUpdateLineUserMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateLineUserMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLineUserMutation, UpdateLineUserMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLineUserMutation, UpdateLineUserMutationVariables>(UpdateLineUserDocument, options);
      }
export type UpdateLineUserMutationHookResult = ReturnType<typeof useUpdateLineUserMutation>;
export type UpdateLineUserMutationResult = Apollo.MutationResult<UpdateLineUserMutation>;
export type UpdateLineUserMutationOptions = Apollo.BaseMutationOptions<UpdateLineUserMutation, UpdateLineUserMutationVariables>;
export const CreateProductDocument = gql`
    mutation createProduct($attributes: ProductAttributes!) {
  createProduct(input: {attributes: $attributes}) {
    products {
      ...productFragment
      factory {
        id
        name
      }
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}`;
export type CreateProductMutationFn = Apollo.MutationFunction<CreateProductMutation, CreateProductMutationVariables>;

/**
 * __useCreateProductMutation__
 *
 * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateProductMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductMutation, CreateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductMutation, CreateProductMutationVariables>(CreateProductDocument, options);
      }
export type CreateProductMutationHookResult = ReturnType<typeof useCreateProductMutation>;
export type CreateProductMutationResult = Apollo.MutationResult<CreateProductMutation>;
export type CreateProductMutationOptions = Apollo.BaseMutationOptions<CreateProductMutation, CreateProductMutationVariables>;
export const RemoveProductDocument = gql`
    mutation removeProduct($id: ID!) {
  removeProduct(input: {id: $id}) {
    product {
      ...productFragment
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}`;
export type RemoveProductMutationFn = Apollo.MutationFunction<RemoveProductMutation, RemoveProductMutationVariables>;

/**
 * __useRemoveProductMutation__
 *
 * To run a mutation, you first call `useRemoveProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeProductMutation, { data, loading, error }] = useRemoveProductMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveProductMutation(baseOptions?: Apollo.MutationHookOptions<RemoveProductMutation, RemoveProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveProductMutation, RemoveProductMutationVariables>(RemoveProductDocument, options);
      }
export type RemoveProductMutationHookResult = ReturnType<typeof useRemoveProductMutation>;
export type RemoveProductMutationResult = Apollo.MutationResult<RemoveProductMutation>;
export type RemoveProductMutationOptions = Apollo.BaseMutationOptions<RemoveProductMutation, RemoveProductMutationVariables>;
export const UpdateProductDocument = gql`
    mutation updateProduct($id: ID!, $attributes: ProductAttributes!) {
  updateProduct(input: {id: $id, attributes: $attributes}) {
    product {
      ...productFragment
      factory {
        id
        name
      }
    }
    error
  }
}
    ${ProductFragmentFragmentDoc}`;
export type UpdateProductMutationFn = Apollo.MutationFunction<UpdateProductMutation, UpdateProductMutationVariables>;

/**
 * __useUpdateProductMutation__
 *
 * To run a mutation, you first call `useUpdateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductMutation, { data, loading, error }] = useUpdateProductMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateProductMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductMutation, UpdateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductMutation, UpdateProductMutationVariables>(UpdateProductDocument, options);
      }
export type UpdateProductMutationHookResult = ReturnType<typeof useUpdateProductMutation>;
export type UpdateProductMutationResult = Apollo.MutationResult<UpdateProductMutation>;
export type UpdateProductMutationOptions = Apollo.BaseMutationOptions<UpdateProductMutation, UpdateProductMutationVariables>;
export const CreateSearchConditionDocument = gql`
    mutation createSearchCondition($attributes: SearchConditionAttributes!) {
  createSearchCondition(input: {attributes: $attributes}) {
    searchConditions {
      ...searchConditionFragment
    }
    error
  }
}
    ${SearchConditionFragmentFragmentDoc}`;
export type CreateSearchConditionMutationFn = Apollo.MutationFunction<CreateSearchConditionMutation, CreateSearchConditionMutationVariables>;

/**
 * __useCreateSearchConditionMutation__
 *
 * To run a mutation, you first call `useCreateSearchConditionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateSearchConditionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createSearchConditionMutation, { data, loading, error }] = useCreateSearchConditionMutation({
 *   variables: {
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useCreateSearchConditionMutation(baseOptions?: Apollo.MutationHookOptions<CreateSearchConditionMutation, CreateSearchConditionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateSearchConditionMutation, CreateSearchConditionMutationVariables>(CreateSearchConditionDocument, options);
      }
export type CreateSearchConditionMutationHookResult = ReturnType<typeof useCreateSearchConditionMutation>;
export type CreateSearchConditionMutationResult = Apollo.MutationResult<CreateSearchConditionMutation>;
export type CreateSearchConditionMutationOptions = Apollo.BaseMutationOptions<CreateSearchConditionMutation, CreateSearchConditionMutationVariables>;
export const RemoveSearchConditionDocument = gql`
    mutation removeSearchCondition($id: ID!) {
  removeSearchCondition(input: {id: $id}) {
    searchCondition {
      ...searchConditionFragment
    }
    error
  }
}
    ${SearchConditionFragmentFragmentDoc}`;
export type RemoveSearchConditionMutationFn = Apollo.MutationFunction<RemoveSearchConditionMutation, RemoveSearchConditionMutationVariables>;

/**
 * __useRemoveSearchConditionMutation__
 *
 * To run a mutation, you first call `useRemoveSearchConditionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveSearchConditionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeSearchConditionMutation, { data, loading, error }] = useRemoveSearchConditionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveSearchConditionMutation(baseOptions?: Apollo.MutationHookOptions<RemoveSearchConditionMutation, RemoveSearchConditionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveSearchConditionMutation, RemoveSearchConditionMutationVariables>(RemoveSearchConditionDocument, options);
      }
export type RemoveSearchConditionMutationHookResult = ReturnType<typeof useRemoveSearchConditionMutation>;
export type RemoveSearchConditionMutationResult = Apollo.MutationResult<RemoveSearchConditionMutation>;
export type RemoveSearchConditionMutationOptions = Apollo.BaseMutationOptions<RemoveSearchConditionMutation, RemoveSearchConditionMutationVariables>;
export const UpdateSearchConditionDocument = gql`
    mutation updateSearchCondition($id: ID!, $attributes: SearchConditionAttributes!) {
  updateSearchCondition(input: {id: $id, attributes: $attributes}) {
    searchCondition {
      ...searchConditionFragment
    }
    error
  }
}
    ${SearchConditionFragmentFragmentDoc}`;
export type UpdateSearchConditionMutationFn = Apollo.MutationFunction<UpdateSearchConditionMutation, UpdateSearchConditionMutationVariables>;

/**
 * __useUpdateSearchConditionMutation__
 *
 * To run a mutation, you first call `useUpdateSearchConditionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSearchConditionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSearchConditionMutation, { data, loading, error }] = useUpdateSearchConditionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      attributes: // value for 'attributes'
 *   },
 * });
 */
export function useUpdateSearchConditionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSearchConditionMutation, UpdateSearchConditionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSearchConditionMutation, UpdateSearchConditionMutationVariables>(UpdateSearchConditionDocument, options);
      }
export type UpdateSearchConditionMutationHookResult = ReturnType<typeof useUpdateSearchConditionMutation>;
export type UpdateSearchConditionMutationResult = Apollo.MutationResult<UpdateSearchConditionMutation>;
export type UpdateSearchConditionMutationOptions = Apollo.BaseMutationOptions<UpdateSearchConditionMutation, UpdateSearchConditionMutationVariables>;
export const CodesDocument = gql`
    query codes($search: MasterSearch) {
  codes(search: $search) {
    ...codeFragment
    line {
      id
      name
      factoryId
      productId
      factory {
        ...factoryFragment
      }
      product {
        ...productFragment
      }
    }
  }
}
    ${CodeFragmentFragmentDoc}
${FactoryFragmentFragmentDoc}
${ProductFragmentFragmentDoc}`;

/**
 * __useCodesQuery__
 *
 * To run a query within a React component, call `useCodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useCodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCodesQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useCodesQuery(baseOptions?: Apollo.QueryHookOptions<CodesQuery, CodesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CodesQuery, CodesQueryVariables>(CodesDocument, options);
      }
export function useCodesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CodesQuery, CodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CodesQuery, CodesQueryVariables>(CodesDocument, options);
        }
export function useCodesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<CodesQuery, CodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<CodesQuery, CodesQueryVariables>(CodesDocument, options);
        }
export type CodesQueryHookResult = ReturnType<typeof useCodesQuery>;
export type CodesLazyQueryHookResult = ReturnType<typeof useCodesLazyQuery>;
export type CodesSuspenseQueryHookResult = ReturnType<typeof useCodesSuspenseQuery>;
export type CodesQueryResult = Apollo.QueryResult<CodesQuery, CodesQueryVariables>;
export const FactoriesDocument = gql`
    query factories($search: MasterSearch) {
  factories(search: $search) {
    ...factoryFragment
  }
}
    ${FactoryFragmentFragmentDoc}`;

/**
 * __useFactoriesQuery__
 *
 * To run a query within a React component, call `useFactoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useFactoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useFactoriesQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useFactoriesQuery(baseOptions?: Apollo.QueryHookOptions<FactoriesQuery, FactoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<FactoriesQuery, FactoriesQueryVariables>(FactoriesDocument, options);
      }
export function useFactoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<FactoriesQuery, FactoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<FactoriesQuery, FactoriesQueryVariables>(FactoriesDocument, options);
        }
export function useFactoriesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<FactoriesQuery, FactoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<FactoriesQuery, FactoriesQueryVariables>(FactoriesDocument, options);
        }
export type FactoriesQueryHookResult = ReturnType<typeof useFactoriesQuery>;
export type FactoriesLazyQueryHookResult = ReturnType<typeof useFactoriesLazyQuery>;
export type FactoriesSuspenseQueryHookResult = ReturnType<typeof useFactoriesSuspenseQuery>;
export type FactoriesQueryResult = Apollo.QueryResult<FactoriesQuery, FactoriesQueryVariables>;
export const LineDocument = gql`
    query line($id: ID!) {
  line(id: $id) {
    id
    name
    factoryId
    productId
    takt
    codeCount
    userCount
    factory {
      ...factoryFragment
    }
    product {
      ...productFragment
    }
  }
}
    ${FactoryFragmentFragmentDoc}
${ProductFragmentFragmentDoc}`;

/**
 * __useLineQuery__
 *
 * To run a query within a React component, call `useLineQuery` and pass it any options that fit your needs.
 * When your component renders, `useLineQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLineQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useLineQuery(baseOptions: Apollo.QueryHookOptions<LineQuery, LineQueryVariables> & ({ variables: LineQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LineQuery, LineQueryVariables>(LineDocument, options);
      }
export function useLineLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LineQuery, LineQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LineQuery, LineQueryVariables>(LineDocument, options);
        }
export function useLineSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LineQuery, LineQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LineQuery, LineQueryVariables>(LineDocument, options);
        }
export type LineQueryHookResult = ReturnType<typeof useLineQuery>;
export type LineLazyQueryHookResult = ReturnType<typeof useLineLazyQuery>;
export type LineSuspenseQueryHookResult = ReturnType<typeof useLineSuspenseQuery>;
export type LineQueryResult = Apollo.QueryResult<LineQuery, LineQueryVariables>;
export const LinesDocument = gql`
    query lines($search: MasterSearch) {
  lines(search: $search) {
    id
    name
    factoryId
    productId
    takt
    codeCount
    userCount
    factory {
      ...factoryFragment
    }
    product {
      ...productFragment
    }
  }
}
    ${FactoryFragmentFragmentDoc}
${ProductFragmentFragmentDoc}`;

/**
 * __useLinesQuery__
 *
 * To run a query within a React component, call `useLinesQuery` and pass it any options that fit your needs.
 * When your component renders, `useLinesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLinesQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useLinesQuery(baseOptions?: Apollo.QueryHookOptions<LinesQuery, LinesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LinesQuery, LinesQueryVariables>(LinesDocument, options);
      }
export function useLinesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LinesQuery, LinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LinesQuery, LinesQueryVariables>(LinesDocument, options);
        }
export function useLinesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LinesQuery, LinesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LinesQuery, LinesQueryVariables>(LinesDocument, options);
        }
export type LinesQueryHookResult = ReturnType<typeof useLinesQuery>;
export type LinesLazyQueryHookResult = ReturnType<typeof useLinesLazyQuery>;
export type LinesSuspenseQueryHookResult = ReturnType<typeof useLinesSuspenseQuery>;
export type LinesQueryResult = Apollo.QueryResult<LinesQuery, LinesQueryVariables>;
export const LineErrorsDocument = gql`
    query lineErrors($search: MasterSearch) {
  lineErrors(search: $search) {
    ...lineErrorFragment
    line {
      id
      name
      factoryId
      productId
      factory {
        ...factoryFragment
      }
      product {
        ...productFragment
      }
    }
  }
}
    ${LineErrorFragmentFragmentDoc}
${FactoryFragmentFragmentDoc}
${ProductFragmentFragmentDoc}`;

/**
 * __useLineErrorsQuery__
 *
 * To run a query within a React component, call `useLineErrorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useLineErrorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLineErrorsQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useLineErrorsQuery(baseOptions?: Apollo.QueryHookOptions<LineErrorsQuery, LineErrorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LineErrorsQuery, LineErrorsQueryVariables>(LineErrorsDocument, options);
      }
export function useLineErrorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LineErrorsQuery, LineErrorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LineErrorsQuery, LineErrorsQueryVariables>(LineErrorsDocument, options);
        }
export function useLineErrorsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LineErrorsQuery, LineErrorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LineErrorsQuery, LineErrorsQueryVariables>(LineErrorsDocument, options);
        }
export type LineErrorsQueryHookResult = ReturnType<typeof useLineErrorsQuery>;
export type LineErrorsLazyQueryHookResult = ReturnType<typeof useLineErrorsLazyQuery>;
export type LineErrorsSuspenseQueryHookResult = ReturnType<typeof useLineErrorsSuspenseQuery>;
export type LineErrorsQueryResult = Apollo.QueryResult<LineErrorsQuery, LineErrorsQueryVariables>;
export const LineUsersDocument = gql`
    query lineUsers($search: MasterSearch) {
  lineUsers(search: $search) {
    ...lineUserFragment
    line {
      id
      name
      factoryId
      productId
      factory {
        ...factoryFragment
      }
      product {
        ...productFragment
      }
    }
    user {
      ...userFragment
    }
  }
}
    ${LineUserFragmentFragmentDoc}
${FactoryFragmentFragmentDoc}
${ProductFragmentFragmentDoc}
${UserFragmentFragmentDoc}`;

/**
 * __useLineUsersQuery__
 *
 * To run a query within a React component, call `useLineUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useLineUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLineUsersQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useLineUsersQuery(baseOptions?: Apollo.QueryHookOptions<LineUsersQuery, LineUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LineUsersQuery, LineUsersQueryVariables>(LineUsersDocument, options);
      }
export function useLineUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LineUsersQuery, LineUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LineUsersQuery, LineUsersQueryVariables>(LineUsersDocument, options);
        }
export function useLineUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<LineUsersQuery, LineUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<LineUsersQuery, LineUsersQueryVariables>(LineUsersDocument, options);
        }
export type LineUsersQueryHookResult = ReturnType<typeof useLineUsersQuery>;
export type LineUsersLazyQueryHookResult = ReturnType<typeof useLineUsersLazyQuery>;
export type LineUsersSuspenseQueryHookResult = ReturnType<typeof useLineUsersSuspenseQuery>;
export type LineUsersQueryResult = Apollo.QueryResult<LineUsersQuery, LineUsersQueryVariables>;
export const ProductsDocument = gql`
    query products($search: MasterSearch) {
  products(search: $search) {
    ...productFragment
    factory {
      ...factoryFragment
    }
  }
}
    ${ProductFragmentFragmentDoc}
${FactoryFragmentFragmentDoc}`;

/**
 * __useProductsQuery__
 *
 * To run a query within a React component, call `useProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProductsQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useProductsQuery(baseOptions?: Apollo.QueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
      }
export function useProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export function useProductsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ProductsQuery, ProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ProductsQuery, ProductsQueryVariables>(ProductsDocument, options);
        }
export type ProductsQueryHookResult = ReturnType<typeof useProductsQuery>;
export type ProductsLazyQueryHookResult = ReturnType<typeof useProductsLazyQuery>;
export type ProductsSuspenseQueryHookResult = ReturnType<typeof useProductsSuspenseQuery>;
export type ProductsQueryResult = Apollo.QueryResult<ProductsQuery, ProductsQueryVariables>;
export const ReportAvailabilityRateDocument = gql`
    query reportAvailabilityRate($search: ReportSearch) {
  reportAvailabilityRate(search: $search) {
    lineId
    lineName
    date
    rate
    prevRate
  }
}
    `;

/**
 * __useReportAvailabilityRateQuery__
 *
 * To run a query within a React component, call `useReportAvailabilityRateQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportAvailabilityRateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportAvailabilityRateQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useReportAvailabilityRateQuery(baseOptions?: Apollo.QueryHookOptions<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>(ReportAvailabilityRateDocument, options);
      }
export function useReportAvailabilityRateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>(ReportAvailabilityRateDocument, options);
        }
export function useReportAvailabilityRateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>(ReportAvailabilityRateDocument, options);
        }
export type ReportAvailabilityRateQueryHookResult = ReturnType<typeof useReportAvailabilityRateQuery>;
export type ReportAvailabilityRateLazyQueryHookResult = ReturnType<typeof useReportAvailabilityRateLazyQuery>;
export type ReportAvailabilityRateSuspenseQueryHookResult = ReturnType<typeof useReportAvailabilityRateSuspenseQuery>;
export type ReportAvailabilityRateQueryResult = Apollo.QueryResult<ReportAvailabilityRateQuery, ReportAvailabilityRateQueryVariables>;
export const ReportDailyLineCodesDocument = gql`
    query reportDailyLineCodes($search: ReportSearch) {
  reportDailyLineCodes(search: $search) {
    date
    count
  }
}
    `;

/**
 * __useReportDailyLineCodesQuery__
 *
 * To run a query within a React component, call `useReportDailyLineCodesQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportDailyLineCodesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportDailyLineCodesQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useReportDailyLineCodesQuery(baseOptions?: Apollo.QueryHookOptions<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>(ReportDailyLineCodesDocument, options);
      }
export function useReportDailyLineCodesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>(ReportDailyLineCodesDocument, options);
        }
export function useReportDailyLineCodesSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>(ReportDailyLineCodesDocument, options);
        }
export type ReportDailyLineCodesQueryHookResult = ReturnType<typeof useReportDailyLineCodesQuery>;
export type ReportDailyLineCodesLazyQueryHookResult = ReturnType<typeof useReportDailyLineCodesLazyQuery>;
export type ReportDailyLineCodesSuspenseQueryHookResult = ReturnType<typeof useReportDailyLineCodesSuspenseQuery>;
export type ReportDailyLineCodesQueryResult = Apollo.QueryResult<ReportDailyLineCodesQuery, ReportDailyLineCodesQueryVariables>;
export const ReportErrorsDocument = gql`
    query reportErrors($search: ReportSearch) {
  reportErrors(search: $search) {
    lineName
    count
  }
}
    `;

/**
 * __useReportErrorsQuery__
 *
 * To run a query within a React component, call `useReportErrorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportErrorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportErrorsQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useReportErrorsQuery(baseOptions?: Apollo.QueryHookOptions<ReportErrorsQuery, ReportErrorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportErrorsQuery, ReportErrorsQueryVariables>(ReportErrorsDocument, options);
      }
export function useReportErrorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportErrorsQuery, ReportErrorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportErrorsQuery, ReportErrorsQueryVariables>(ReportErrorsDocument, options);
        }
export function useReportErrorsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ReportErrorsQuery, ReportErrorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ReportErrorsQuery, ReportErrorsQueryVariables>(ReportErrorsDocument, options);
        }
export type ReportErrorsQueryHookResult = ReturnType<typeof useReportErrorsQuery>;
export type ReportErrorsLazyQueryHookResult = ReturnType<typeof useReportErrorsLazyQuery>;
export type ReportErrorsSuspenseQueryHookResult = ReturnType<typeof useReportErrorsSuspenseQuery>;
export type ReportErrorsQueryResult = Apollo.QueryResult<ReportErrorsQuery, ReportErrorsQueryVariables>;
export const ReportLineRateDocument = gql`
    query reportLineRate($search: ReportSearch) {
  reportLineRate(search: $search) {
    month
    lineId
    lineName
    rate
  }
}
    `;

/**
 * __useReportLineRateQuery__
 *
 * To run a query within a React component, call `useReportLineRateQuery` and pass it any options that fit your needs.
 * When your component renders, `useReportLineRateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useReportLineRateQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useReportLineRateQuery(baseOptions?: Apollo.QueryHookOptions<ReportLineRateQuery, ReportLineRateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ReportLineRateQuery, ReportLineRateQueryVariables>(ReportLineRateDocument, options);
      }
export function useReportLineRateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ReportLineRateQuery, ReportLineRateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ReportLineRateQuery, ReportLineRateQueryVariables>(ReportLineRateDocument, options);
        }
export function useReportLineRateSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<ReportLineRateQuery, ReportLineRateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<ReportLineRateQuery, ReportLineRateQueryVariables>(ReportLineRateDocument, options);
        }
export type ReportLineRateQueryHookResult = ReturnType<typeof useReportLineRateQuery>;
export type ReportLineRateLazyQueryHookResult = ReturnType<typeof useReportLineRateLazyQuery>;
export type ReportLineRateSuspenseQueryHookResult = ReturnType<typeof useReportLineRateSuspenseQuery>;
export type ReportLineRateQueryResult = Apollo.QueryResult<ReportLineRateQuery, ReportLineRateQueryVariables>;
export const SearchConditionsDocument = gql`
    query searchConditions($search: SearchConditionSearch) {
  searchConditions(search: $search) {
    ...searchConditionFragment
  }
}
    ${SearchConditionFragmentFragmentDoc}`;

/**
 * __useSearchConditionsQuery__
 *
 * To run a query within a React component, call `useSearchConditionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchConditionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchConditionsQuery({
 *   variables: {
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchConditionsQuery(baseOptions?: Apollo.QueryHookOptions<SearchConditionsQuery, SearchConditionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchConditionsQuery, SearchConditionsQueryVariables>(SearchConditionsDocument, options);
      }
export function useSearchConditionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchConditionsQuery, SearchConditionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchConditionsQuery, SearchConditionsQueryVariables>(SearchConditionsDocument, options);
        }
export function useSearchConditionsSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<SearchConditionsQuery, SearchConditionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<SearchConditionsQuery, SearchConditionsQueryVariables>(SearchConditionsDocument, options);
        }
export type SearchConditionsQueryHookResult = ReturnType<typeof useSearchConditionsQuery>;
export type SearchConditionsLazyQueryHookResult = ReturnType<typeof useSearchConditionsLazyQuery>;
export type SearchConditionsSuspenseQueryHookResult = ReturnType<typeof useSearchConditionsSuspenseQuery>;
export type SearchConditionsQueryResult = Apollo.QueryResult<SearchConditionsQuery, SearchConditionsQueryVariables>;
export const UserDocument = gql`
    query user($id: ID!) {
  user(id: $id) {
    ...userFragment
  }
}
    ${UserFragmentFragmentDoc}`;

/**
 * __useUserQuery__
 *
 * To run a query within a React component, call `useUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUserQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useUserQuery(baseOptions: Apollo.QueryHookOptions<UserQuery, UserQueryVariables> & ({ variables: UserQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UserQuery, UserQueryVariables>(UserDocument, options);
      }
export function useUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export function useUserSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UserQuery, UserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UserQuery, UserQueryVariables>(UserDocument, options);
        }
export type UserQueryHookResult = ReturnType<typeof useUserQuery>;
export type UserLazyQueryHookResult = ReturnType<typeof useUserLazyQuery>;
export type UserSuspenseQueryHookResult = ReturnType<typeof useUserSuspenseQuery>;
export type UserQueryResult = Apollo.QueryResult<UserQuery, UserQueryVariables>;
export const UsersDocument = gql`
    query users {
  users {
    ...userFragment
  }
}
    ${UserFragmentFragmentDoc}`;

/**
 * __useUsersQuery__
 *
 * To run a query within a React component, call `useUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useUsersQuery(baseOptions?: Apollo.QueryHookOptions<UsersQuery, UsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
      }
export function useUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export function useUsersSuspenseQuery(baseOptions?: Apollo.SuspenseQueryHookOptions<UsersQuery, UsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<UsersQuery, UsersQueryVariables>(UsersDocument, options);
        }
export type UsersQueryHookResult = ReturnType<typeof useUsersQuery>;
export type UsersLazyQueryHookResult = ReturnType<typeof useUsersLazyQuery>;
export type UsersSuspenseQueryHookResult = ReturnType<typeof useUsersSuspenseQuery>;
export type UsersQueryResult = Apollo.QueryResult<UsersQuery, UsersQueryVariables>;